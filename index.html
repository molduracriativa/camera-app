<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<title>Moldura Criativa - C√¢mera (Final Corrigido)</title>

<!-- FFmpeg para convers√£o MP4 -->
<script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.5/dist/ffmpeg.min.js"></script>

<style>
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{
    width:100%;height:100%;background:#000;color:#fff;
    font-family:system-ui,-apple-system;
    -webkit-user-select:none;user-select:none;
    -webkit-touch-callout:none; touch-action:manipulation;
    overflow:hidden;
  }

  #video{position:fixed;inset:0;width:100vw;height:100vh;object-fit:cover;z-index:1;pointer-events:none}
  #frame{position:fixed;inset:0;width:100vw;height:100vh;object-fit:contain;z-index:3;pointer-events:none}
  #enable{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#fff;color:#000;padding:16px 26px;border-radius:12px;border:none;z-index:10}
  #controls{position:fixed;left:0;right:0;bottom:28px;display:none;justify-content:center;gap:36px;z-index:10}
  .btn{width:78px;height:78px;border-radius:50%;background:#fff;border:none;font-size:28px;display:flex;align-items:center;justify-content:center;box-shadow:0 6px 18px rgba(0,0,0,0.4)}
  .btn.recording{background:#e53935;color:#fff}

  #timer{position:fixed;top:18px;left:50%;transform:translateX(-50%);font-size:22px;z-index:15;display:none}
  #preview{position:fixed;inset:0;background:#000;display:none;align-items:center;justify-content:center;z-index:30}
  #preview video,#preview img{max-width:100%;max-height:100%;object-fit:contain}
  #preview-buttons{position:fixed;bottom:28px;left:0;right:0;display:none;justify-content:center;gap:28px;z-index:35}
  .pbtn{background:#fff;color:#000;border:none;padding:12px 20px;border-radius:10px;font-size:18px}
  /* avoid selection / long-press */
  button{ -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
</style>
</head>
<body>

<button id="enable">Ativar C√¢mera</button>

<video id="video" autoplay playsinline muted></video>
<img id="frame" src="assets/moldura.png" alt="moldura"/>

<canvas id="canvas" width="1080" height="1920" style="display:none"></canvas>

<div id="controls">
  <button id="switch" class="btn">üîÑ</button>
  <button id="photo" class="btn">üì∏</button>
  <button id="record" class="btn">‚è∫</button>
</div>

<div id="timer">0.0s</div>

<!-- Preview fullscreen -->
<div id="preview">
  <video id="previewVideo" controls playsinline style="display:none"></video>
  <img id="previewPhoto" style="display:none"/>
</div>

<div id="preview-buttons">
  <button id="save" class="pbtn">Salvar</button>
  <button id="retry" class="pbtn">Refazer</button>
</div>

<script>
/* ===== Elements ===== */
const enable = document.getElementById('enable');
const video = document.getElementById('video');
const frame = document.getElementById('frame');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const controls = document.getElementById('controls');
const switchBtn = document.getElementById('switch');
const photoBtn = document.getElementById('photo');
const recordBtn = document.getElementById('record');

const timerEl = document.getElementById('timer');
const preview = document.getElementById('preview');
const previewVideo = document.getElementById('previewVideo');
const previewPhoto = document.getElementById('previewPhoto');
const previewButtons = document.getElementById('preview-buttons');
const saveBtn = document.getElementById('save');
const retryBtn = document.getElementById('retry');

let stream = null;
let usingFront = true;
let recorder = null;
let recordedChunks = [];
let recording = false;
let timerInterval = null;
let elapsed = 0;

/* Prevent default long-press context on mobile */
document.addEventListener('contextmenu', e => e.preventDefault());

/* ===== Start camera ===== */
async function startCamera(){
  try {
    if (stream) stream.getTracks().forEach(t=>t.stop());
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: usingFront ? 'user' : 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } },
      audio: true
    });
    video.srcObject = stream;
    video.muted = true;
    video.setAttribute('playsinline', '');
    await video.play();

    enable.style.display = 'none';
    controls.style.display = 'flex';
  } catch (err) {
    console.error(err);
    alert('Erro ao abrir c√¢mera: ' + (err && err.message ? err.message : err));
  }
}
enable.addEventListener('click', startCamera);
switchBtn.addEventListener('click', async () => { usingFront = !usingFront; await startCamera(); });

/* ===== Draw video + frame to canvas (1080x1920) ===== */
function drawToCanvas(){
  const vw = video.videoWidth || canvas.width;
  const vh = video.videoHeight || canvas.height;

  // logical canvas already 1080x1920
  canvas.width = 1080;
  canvas.height = 1920;

  // fill black
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // scale video to fill height
  const scale = canvas.height / vh;
  const drawW = vw * scale;
  const drawH = canvas.height;
  const dx = (canvas.width - drawW) / 2;

  if (usingFront) {
    ctx.save();
    ctx.translate(dx + drawW, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(video, 0, 0, vw, vh, 0, 0, drawW, drawH);
    ctx.restore();
  } else {
    ctx.drawImage(video, 0, 0, vw, vh, dx, 0, drawW, drawH);
  }

  // draw frame scaled by height
  if (frame && frame.naturalWidth) {
    const fw = frame.naturalWidth;
    const fh = frame.naturalHeight;
    const fScale = canvas.height / fh;
    const fW = fw * fScale;
    const fDX = (canvas.width - fW) / 2;
    ctx.drawImage(frame, 0, 0, fw, fh, fDX, 0, fW, canvas.height);
  }
}

/* ===== PHOTO capture ===== */
photoBtn.addEventListener('click', () => {
  // ensure video metadata available
  if (!video.videoWidth) { alert('Aguardando c√¢mera...'); return; }
  drawToCanvas();
  const dataUrl = canvas.toDataURL('image/png');

  // show preview fullscreen
  preview.style.display = 'flex';
  previewPhoto.style.display = 'block';
  previewPhoto.src = dataUrl;
  previewVideo.style.display = 'none';
  previewButtons.style.display = 'flex';

  // bind save/refazer for photo
  saveBtn.onclick = () => {
    const a = document.createElement('a');
    a.href = dataUrl;
    a.download = 'foto.png';
    a.click();
  };
  retryBtn.onclick = () => {
    preview.style.display = 'none';
    previewButtons.style.display = 'none';
    previewPhoto.src = '';
  };
});

/* ===== RECORDING helpers ===== */
function startTimer(){
  elapsed = 0;
  timerEl.style.display = 'block';
  timerEl.textContent = '0.0s';
  timerInterval = setInterval(()=>{
    elapsed += 0.1;
    timerEl.textContent = elapsed.toFixed(1) + 's';
  },100);
}
function stopTimer(){
  clearInterval(timerInterval);
  timerInterval = null;
  timerEl.style.display = 'none';
  timerEl.textContent = '0.0s';
}

/* Start recording: set up MediaRecorder on canvas stream */
async function startRecording(){
  if (!video.videoWidth || !stream) { alert('Abra a c√¢mera primeiro'); return; }

  // ensure canvas has content before capture
  drawToCanvas();

  const canvasStream = canvas.captureStream(30);
  // add audio track if available
  const audioTracks = stream.getAudioTracks();
  if (audioTracks && audioTracks.length) {
    try { canvasStream.addTrack(audioTracks[0]); } catch(e){ console.warn('could not add audio', e); }
  }

  recordedChunks = [];
  // choose a sensible mime (fallbacks handled by browser)
  let options = {};
  const preferred = 'video/webm;codecs=vp8,opus';
  try { if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(preferred)) options.mimeType = preferred; } catch(e){}

  recorder = new MediaRecorder(canvasStream, options);

  recorder.ondataavailable = e => { if (e.data && e.data.size) recordedChunks.push(e.data); };
  recorder.onstop = async () => {
    // stop timer
    stopTimer();
    recordBtn.classList.remove('recording');

    const webmBlob = new Blob(recordedChunks, { type: recordedChunks[0]?.type || 'video/webm' });

    // convert with ffmpeg
    try {
      // show preview while converting (spinner could be added)
      showConvertingUI(true);
      const ffmpeg = FFmpeg.createFFmpeg({ log: false });
      await ffmpeg.load();

      const data = await FFmpeg.fetchFile(webmBlob);
      ffmpeg.FS('writeFile','input.webm',data);

      await ffmpeg.run(
        '-i','input.webm',
        '-c:v','libx264',
        '-preset','veryfast',
        '-crf','23',
        '-c:a','aac',
        '-b:a','128k',
        '-movflags','faststart',
        'output.mp4'
      );

      const mp4Data = ffmpeg.FS('readFile','output.mp4');
      const mp4Blob = new Blob([mp4Data.buffer], { type: 'video/mp4' });

      const url = URL.createObjectURL(mp4Blob);
      previewVideo.src = url;
      previewVideo.style.display = 'block';
      previewPhoto.style.display = 'none';
      preview.style.display = 'flex';
      previewButtons.style.display = 'flex';

      // Save handler
      saveBtn.onclick = () => {
        const a = document.createElement('a');
        a.href = url;
        a.download = 'video.mp4';
        a.click();
      };
      // Retry handler
      retryBtn.onclick = () => {
        preview.style.display = 'none';
        previewButtons.style.display = 'none';
        previewVideo.pause();
        previewVideo.src = '';
      };

      // cleanup ffmpeg FS
      try { ffmpeg.FS('unlink','input.webm'); ffmpeg.FS('unlink','output.mp4'); } catch(e){}
    } catch (e) {
      console.error('FFmpeg conversion error', e);
      // fallback: show webm
      const webmUrl = URL.createObjectURL(webmBlob);
      previewVideo.src = webmUrl;
      previewVideo.style.display = 'block';
      previewPhoto.style.display = 'none';
      preview.style.display = 'flex';
      previewButtons.style.display = 'flex';
      saveBtn.onclick = () => { const a = document.createElement('a'); a.href = webmUrl; a.download = 'video.webm'; a.click(); };
      retryBtn.onclick = () => { preview.style.display = 'none'; previewButtons.style.display = 'none'; previewVideo.pause(); previewVideo.src=''; };
    } finally {
      showConvertingUI(false);
      recorder = null;
    }
  };

  recorder.start();
  startTimer();
  recordBtn.classList.add('recording');
}

/* Stop recording */
function stopRecording(){
  if (recorder && recorder.state !== 'inactive') recorder.stop();
}

/* small UI helper while converting */
function showConvertingUI(show){
  if (show) {
    timerEl.style.display = 'block';
    timerEl.textContent = 'Convertendo...';
  } else {
    timerEl.style.display = 'none';
  }
}

/* ===== Wire pointer events for press-and-hold behavior ===== */
/* Use pointerdown/pointerup and also touchcancel to be robust */
function bindPressHold(targetStart, targetEnd){
  // pointer events
  targetStart.addEventListener('pointerdown', async (e) => {
    e.preventDefault();
    // ensure canvas has a frame before starting
    drawToCanvas();
    await startRecording();
  });
  targetStart.addEventListener('pointerup', (e) => {
    e.preventDefault();
    stopRecording();
  });
  targetStart.addEventListener('pointercancel', (e)=> { e.preventDefault(); stopRecording(); });
  // fallback for touch events on some older browsers
  targetStart.addEventListener('touchstart', async (e) => { e.preventDefault(); drawToCanvas(); await startRecording(); }, {passive:false});
  targetStart.addEventListener('touchend', (e) => { e.preventDefault(); stopRecording(); });
  targetStart.addEventListener('touchcancel', (e)=> { e.preventDefault(); stopRecording(); });
}

/* attach to record button */
bindPressHold(recordBtn);

/* also allow keyboard / click fallback: click to toggle */
recordBtn.addEventListener('click', (e) => {
  // if click happens without pointerdown/up sequence, toggle record for accessibility
  if (!recorder) {
    // start and stop after short delay if user just clicks ‚Äî fallback: start then stop after 3s
    (async () => {
      drawToCanvas();
      await startRecording();
      setTimeout(() => stopRecording(), 3000);
    })();
  }
});

/* Prevent multiple fast clicks from hiding preview buttons incorrectly */
saveBtn.addEventListener('click', () => {
  // handler replaced dynamically when appropriate (photo/video)
});
retryBtn.addEventListener('click', () => {
  // handler replaced dynamically when appropriate
});

/* Clean up on pagehide */
window.addEventListener('pagehide', () => {
  try { if (stream) stream.getTracks().forEach(t=>t.stop()); } catch(e){}
  stopTimer();
});

/* End of script */
</script>
</body>
</html>
