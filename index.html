<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<title>Moldura Criativa - Fix Save/Retry</title>

<!-- FFmpeg (lazy load inside script) -->
<script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.5/dist/ffmpeg.min.js"></script>

<style>
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{
    width:100%;height:100%;background:#000;overflow:hidden;
    font-family:system-ui,-apple-system; -webkit-user-select:none; user-select:none;
    -webkit-touch-callout:none; touch-action:manipulation;
  }

  #video{position:fixed;inset:0;width:100vw;height:100vh;object-fit:cover;z-index:1;pointer-events:none;background:#000}
  #frame{position:fixed;inset:0;width:100vw;height:100vh;object-fit:contain;z-index:3;pointer-events:none;opacity:0;transition:opacity .2s}
  #enable{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#fff;color:#000;padding:16px 24px;border-radius:12px;border:none;z-index:22}
  #controls{position:fixed;bottom:30px;left:0;right:0;display:none;justify-content:center;gap:36px;z-index:20}
  .btn{width:78px;height:78px;border-radius:50%;background:#fff;border:none;font-size:26px;display:flex;align-items:center;justify-content:center;box-shadow:0 8px 20px rgba(0,0,0,0.45);touch-action:none}
  #timer{position:fixed;top:18px;left:50%;transform:translateX(-50%);font-size:22px;color:#fff;display:none;z-index:21}
  #preview{position:fixed;inset:0;background:#000;display:none;align-items:center;justify-content:center;z-index:50;pointer-events:auto}
  #preview video,#preview img{max-width:100%;max-height:100%;object-fit:contain;pointer-events:auto}
  #preview-buttons{position:fixed;bottom:30px;left:0;right:0;display:none;flex-direction:column;align-items:center;gap:14px;z-index:60;pointer-events:auto}
  .pbtn{width:68%;max-width:360px;padding:14px 20px;border-radius:12px;border:none;background:#fff;color:#000;font-size:18px}
  button{ -webkit-tap-highlight-color: transparent; }
</style>
</head>
<body>

<button id="enable">Ativar C√¢mera</button>

<video id="video" autoplay playsinline muted></video>
<img id="frame" src="assets/moldura.png" alt="moldura"/>

<canvas id="canvas" width="1080" height="1920" style="display:none"></canvas>

<div id="controls">
  <button id="switch" class="btn">üîÑ</button>
  <button id="photo" class="btn">üì∏</button>
  <button id="record" class="btn">‚è∫</button>
</div>

<div id="timer">0.0s</div>

<div id="preview">
  <video id="previewVideo" controls playsinline style="display:none"></video>
  <img id="previewPhoto" style="display:none"/>
</div>

<div id="preview-buttons" aria-hidden="true">
  <button id="save" class="pbtn">Salvar</button>
  <button id="retry" class="pbtn">Refazer</button>
</div>

<script>
/* ========== Elements & State ========== */
const enable = document.getElementById('enable');
const video = document.getElementById('video');
const frame = document.getElementById('frame');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const controls = document.getElementById('controls');
const switchBtn = document.getElementById('switch');
const photoBtn = document.getElementById('photo');
const recordBtn = document.getElementById('record');

const timerEl = document.getElementById('timer');
const preview = document.getElementById('preview');
const previewVideo = document.getElementById('previewVideo');
const previewPhoto = document.getElementById('previewPhoto');
const previewButtons = document.getElementById('preview-buttons');
const saveBtn = document.getElementById('save');
const retryBtn = document.getElementById('retry');

let stream = null;
let usingFront = true;
let recorder = null;
let recordedChunks = [];
let elapsed = 0;
let timerInt = null;
let ffmpeg = null;
let ffmpegLoading = false;
let videoReady = false;

/* prevent longpress menu on mobile */
document.addEventListener('contextmenu', e => e.preventDefault());

/* ========== Utilities ========== */
function safeReplaceHandler(el, eventName, handler) {
  // remove all previous listeners for that event by cloning (simple and robust)
  const newEl = el.cloneNode(true);
  el.parentNode.replaceChild(newEl, el);
  newEl.addEventListener(eventName, handler);
  return newEl;
}

function setSaveHandlerForBlob(blob, filename, mime) {
  // ensure previous handlers removed
  const newSave = saveBtn.cloneNode(true);
  saveBtn.parentNode.replaceChild(newSave, saveBtn);
  // replace global ref
  window.__saveBtnRef = newSave;

  newSave.addEventListener('click', async () => {
    try {
      const file = new File([blob], filename, { type: mime });
      // Web Share Level 2
      if (navigator.canShare && navigator.canShare({ files: [file] })) {
        await navigator.share({ files: [file], title: filename });
      } else if (navigator.share) {
        // fallback: share URL
        const url = URL.createObjectURL(blob);
        try {
          await navigator.share({ url, title: filename });
          URL.revokeObjectURL(url);
        } catch (e) {
          URL.revokeObjectURL(url);
          // final fallback -> download
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          a.click();
        }
      } else {
        // fallback -> download
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      }
    } catch (err) {
      console.warn('save failed fallback to download', err);
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }
  });

  // Update saveBtn reference
  window.__saveBtnRef = newSave;
  return newSave;
}

function setRetryHandler(handler) {
  const newRetry = retryBtn.cloneNode(true);
  retryBtn.parentNode.replaceChild(newRetry, retryBtn);
  newRetry.addEventListener('click', handler);
  window.__retryBtnRef = newRetry;
  return newRetry;
}

/* ========== Camera Start ========== */
async function startCamera(){
  try {
    videoReady = false;
    if (stream) stream.getTracks().forEach(t=>t.stop());

    const constraints = {
      video: { facingMode: usingFront ? 'user' : 'environment', width:{ ideal:1280 }, height:{ ideal:720 } },
      audio: true
    };

    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    video.muted = true;
    video.setAttribute('playsinline', '');

    // wait for metadata reliably (avoid premature recording)
    await new Promise(res => {
      const onMeta = () => {
        video.removeEventListener('loadedmetadata', onMeta);
        videoReady = true;
        res();
      };
      video.addEventListener('loadedmetadata', onMeta);
      // safety timeout: if metadata takes too long, still proceed after 3s
      setTimeout(() => {
        if (!videoReady) { videoReady = !!(video.videoWidth && video.videoHeight); res(); }
      }, 3000);
    });

    await video.play();

    // show UI
    enable.style.display = 'none';
    controls.style.display = 'flex';
    // reveal frame (non-blocking)
    if (!frame.complete) frame.onload = () => frame.style.opacity = '1';
    else frame.style.opacity = '1';

    // quick pre-draw so canvas isn't blank
    drawToCanvas();
  } catch (e) {
    console.error('startCamera', e);
    alert('Erro ao abrir c√¢mera: ' + (e && e.message ? e.message : e));
  }
}
enable.addEventListener('click', startCamera);
switchBtn.addEventListener('click', async () => { usingFront = !usingFront; await startCamera(); });

/* ========== Drawing ========== */
function drawToCanvas(){
  if (!videoReady) return;
  const vw = video.videoWidth || canvas.width;
  const vh = video.videoHeight || canvas.height;

  canvas.width = 1080;
  canvas.height = 1920;

  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const scale = canvas.height / vh;
  const drawW = vw * scale;
  const drawH = canvas.height;
  const dx = (canvas.width - drawW) / 2;

  if (usingFront) {
    ctx.save();
    ctx.translate(dx + drawW, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(video, 0,0,vw,vh, 0,0, drawW, drawH);
    ctx.restore();
  } else {
    ctx.drawImage(video, 0,0,vw,vh, dx,0, drawW, drawH);
  }

  if (frame && frame.naturalWidth) {
    const fw = frame.naturalWidth;
    const fh = frame.naturalHeight;
    const fScale = canvas.height / fh;
    const fW = fw * fScale;
    const fDX = (canvas.width - fW) / 2;
    ctx.drawImage(frame, 0,0,fw,fh, fDX,0,fW, canvas.height);
  }
}

/* small continuous draw to keep canvas warm (low-cost) */
let drawRAF = null;
function startDrawLoop(){
  if (drawRAF) return;
  function loop(){
    if (videoReady) drawToCanvas();
    drawRAF = requestAnimationFrame(loop);
  }
  loop();
}
function stopDrawLoop(){
  if (drawRAF) { cancelAnimationFrame(drawRAF); drawRAF = null; }
}

/* ========== Photo capture ========== */
photoBtn.addEventListener('click', async () => {
  if (!videoReady) { alert('Aguarde a c√¢mera abrir'); return; }

  drawToCanvas();
  const dataUrl = canvas.toDataURL('image/png');
  const blob = await (await fetch(dataUrl)).blob();

  preview.style.display = 'flex';
  previewPhoto.style.display = 'block';
  previewVideo.style.display = 'none';
  previewPhoto.src = dataUrl;

  // show buttons
  previewButtons.style.display = 'flex';
  previewButtons.setAttribute('aria-hidden', 'false');

  // set save & retry handlers robustly
  setSaveHandlerForBlob(blob, 'foto.png', blob.type);
  setRetryHandler(() => {
    preview.style.display = 'none';
    previewButtons.style.display = 'none';
    previewPhoto.src = '';
  });
});

/* ========== Recording (press & hold) ========== */
async function ensureFFmpeg(){
  if (ffmpeg || ffmpegLoading) return;
  ffmpegLoading = true;
  try {
    ffmpeg = FFmpeg.createFFmpeg({ log:false });
    await ffmpeg.load();
  } catch (e) {
    console.warn('ffmpeg load failed', e);
    ffmpeg = null;
  } finally {
    ffmpegLoading = false;
  }
}

function startTimer(){
  elapsed = 0;
  timerEl.style.display = 'block';
  timerEl.textContent = '0.0s';
  timerInt = setInterval(()=>{ elapsed += 0.1; timerEl.textContent = elapsed.toFixed(1) + 's'; }, 100);
}
function stopTimer(){
  clearInterval(timerInt); timerInt = null; timerEl.style.display = 'none';
}

async function startRecording(){
  if (!videoReady) {
    // try small wait if visual camera open but metadata late
    let waited = 0;
    while (!video.videoWidth && waited < 3000) { await new Promise(r=>setTimeout(r, 100)); waited += 100; }
    if (!video.videoWidth) { console.warn('video still not ready'); return; }
  }

  drawToCanvas();

  const canvasStream = canvas.captureStream(30);
  const audioTracks = stream ? stream.getAudioTracks() : [];
  if (audioTracks && audioTracks.length) {
    try { canvasStream.addTrack(audioTracks[0]); } catch(e){ console.warn('addTrack failed', e); }
  }

  recordedChunks = [];
  let options = {};
  const mime = 'video/webm;codecs=vp8,opus';
  try { if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(mime)) options.mimeType = mime; } catch(e){}

  recorder = new MediaRecorder(canvasStream, options);
  recorder.ondataavailable = e => { if (e.data && e.data.size) recordedChunks.push(e.data); };

  recorder.onstop = async () => {
    stopTimer();
    recordBtn.classList.remove('recording');

    const webmBlob = new Blob(recordedChunks, { type: recordedChunks[0]?.type || 'video/webm' });

    // show preview UI
    preview.style.display = 'flex';
    previewVideo.style.display = 'block';
    previewPhoto.style.display = 'none';
    previewVideo.src = ''; // will set after conversion
    previewButtons.style.display = 'flex';
    previewButtons.setAttribute('aria-hidden','false');

    // try convert to MP4
    try {
      await ensureFFmpeg();
      if (!ffmpeg) throw new Error('ffmpeg unavailable');

      const data = await FFmpeg.fetchFile(webmBlob);
      ffmpeg.FS('writeFile','input.webm', data);

      await ffmpeg.run(
        '-i','input.webm',
        '-c:v','libx264',
        '-preset','veryfast',
        '-crf','23',
        '-c:a','aac',
        '-b:a','128k',
        '-movflags','faststart',
        'output.mp4'
      );

      const mp4Data = ffmpeg.FS('readFile','output.mp4');
      const mp4Blob = new Blob([mp4Data.buffer], { type: 'video/mp4' });
      const url = URL.createObjectURL(mp4Blob);
      previewVideo.src = url;

      // robust handlers
      setSaveHandlerForBlob(mp4Blob, 'video.mp4', 'video/mp4');
      setRetryHandler(() => {
        preview.style.display = 'none';
        previewButtons.style.display = 'none';
        previewVideo.pause();
        previewVideo.src = '';
      });

      // cleanup
      try { ffmpeg.FS('unlink','input.webm'); ffmpeg.FS('unlink','output.mp4'); } catch(e){}
    } catch (e) {
      console.warn('convert failed, fallback to webm', e);
      const url = URL.createObjectURL(webmBlob);
      previewVideo.src = url;
      setSaveHandlerForBlob(webmBlob, 'video.webm', webmBlob.type);
      setRetryHandler(() => {
        preview.style.display = 'none';
        previewButtons.style.display = 'none';
        previewVideo.pause();
        previewVideo.src = '';
      });
    }
  };

  recorder.start();
  startTimer();
  recordBtn.classList.add('recording');

  // keep drawing while recording
  (function loop(){
    if (recorder && recorder.state !== 'inactive') {
      drawToCanvas();
      requestAnimationFrame(loop);
    }
  })();
}

function stopRecording(){
  if (recorder && recorder.state !== 'inactive') {
    try { recorder.stop(); } catch(e){ console.warn(e); }
  }
}

/* ========== Bind press & hold with pointer + touch fallback ========== */
recordBtn.addEventListener('contextmenu', e => e.preventDefault());

recordBtn.addEventListener('pointerdown', async e => { e.preventDefault(); if (!videoReady) await startCamera(); await startRecording(); });
recordBtn.addEventListener('pointerup', e => { e.preventDefault(); stopRecording(); });
recordBtn.addEventListener('pointercancel', e => { e.preventDefault(); stopRecording(); });

recordBtn.addEventListener('touchstart', async e => { e.preventDefault(); if (!videoReady) await startCamera(); await startRecording(); }, {passive:false});
recordBtn.addEventListener('touchend', e => { e.preventDefault(); stopRecording(); }, {passive:false});
recordBtn.addEventListener('touchcancel', e => { e.preventDefault(); stopRecording(); }, {passive:false});

/* click fallback: short auto-record for accessibility */
recordBtn.addEventListener('click', async (e) => {
  e.preventDefault();
  if (!recorder) {
    if (!videoReady) await startCamera();
    await startRecording();
    setTimeout(()=> stopRecording(), 2500);
  } else {
    stopRecording();
  }
});

/* ensure previewButtons clickable by stopping propagation on preview */
preview.addEventListener('click', (e) => { /* tapping outside preview area could close - we keep it simple */ });

/* draw loop warmup */
startDrawLoop();

/* cleanup */
window.addEventListener('pagehide', () => {
  try { if (stream) stream.getTracks().forEach(t=>t.stop()); } catch(e){}
  stopDrawLoop();
});
</script>
</body>
</html>
