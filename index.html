<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<title>Moldura Criativa - Vers√£o Est√°vel Sem Alertas</title>

<script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.0/dist/ffmpeg.min.js"></script>

<style>
  /* [ESTILOS OMITIDOS PARA BREVIDADE] */
  * { margin:0; padding:0; box-sizing:border-box; }
  html, body {
    width:100%; height:100%;
    background:#000;
    overflow:hidden;
    font-family:system-ui, -apple-system;
    -webkit-user-select:none;
    user-select:none;
    -webkit-touch-callout:none;
    touch-action:manipulation;
  }

  /* V√≠deo da c√¢mera */
  #video {
    position:fixed; inset:0;
    width:100vw; height:100vh;
    object-fit:cover; 
    z-index:1;
    pointer-events:none;
    background:#000;
  }

  /* Moldura */
  #frame {
    position:fixed; inset:0;
    width:100vw; height:100vh;
    object-fit:contain;
    z-index:3;
    pointer-events:none;
    opacity:0;             
    transition:opacity .2s;
  }

  /* Bot√£o ativar c√¢mera (Vis√≠vel apenas se a c√¢mera n√£o abrir automaticamente) */
  #enable {
    position:fixed; left:50%; top:50%;
    transform:translate(-50%, -50%);
    background:#fff; color:#000;
    padding:18px 28px;
    border:none; border-radius:12px;
    font-size:20px;
    z-index:20;
    display:none;
  }

  /* Controles */
  #controls {
    position:fixed; bottom:30px; left:0; right:0;
    display:none; justify-content:center; gap:40px;
    z-index:10;
  }

  .btn {
    width:80px; height:80px;
    background:#fff; border-radius:50%;
    border:none;
    font-size:30px;
    display:flex; align-items:center; justify-content:center;
    box-shadow:0 0 20px #0008;
    touch-action:none;
  }
  
  /* Indicador de grava√ß√£o */
  .btn.recording {
    background: red;
    box-shadow: 0 0 0 8px rgba(255, 0, 0, 0.5);
  }

  /* Timer */
  #timer {
    position:fixed; top:20px; left:50%;
    transform:translateX(-50%);
    font-size:28px; color:#fff;
    display:none; font-weight:600;
    z-index:20;
  }
  
  /* Loading Overlay (para feedback de convers√£o/salvamento) */
  #loading-overlay {
      position: fixed; inset: 0;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      display: none; 
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      z-index: 50;
      padding: 0 40px;
      text-align: center;
  }
  
  #loading-overlay:after {
      content: '';
      width: 40px;
      height: 40px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3498db;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-top: 15px;
  }
  
  /* --- ESTILOS DA PR√âVIA --- */
  #preview {
    position:fixed; inset:0;
    background:#000;
    z-index:30;
    display:none;
    justify-content:center;
    align-items:center;
  }

  #preview video,
  #preview img {
    max-width:100%;
    max-height:100%;
    object-fit:contain;
    pointer-events:auto;
  }

  /* Bot√µes Salvar / Refazer (VERTICAL) */
  #preview-buttons {
    position:fixed; bottom:30px; left:0; right:0;
    display:none;
    flex-direction:column;
    align-items:center;
    gap:20px;
    z-index:40;
    pointer-events:auto;
  }

  .pbtn {
    padding:16px 28px;
    background:#fff;
    border:none;
    border-radius:12px;
    font-size:20px;
    color:#000;
    width:60%;
    text-align:center;
  }
  
  .pbtn:disabled {
      opacity: 0.7;
      cursor: not-allowed;
  }
  
  @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
  }
</style>
</head>
<body onload="startCamera(); ensureFFmpegLoaded();">

<button id="enable">Ativar C√¢mera</button>

<video id="video" autoplay playsinline muted></video>
<img id="frame" src="assets/moldura.png" alt="Moldura"/>

<canvas id="canvas" width="540" height="960" style="display:none"></canvas>

<div id="controls">
  <button id="switch" class="btn">üîÑ</button>
  <button id="photo" class="btn">üì∏</button>
  <button id="record" class="btn">‚è∫</button>
</div>

<div id="timer">0.0s</div>

<div id="preview">
  <video id="previewVideo" controls playsinline style="display:none"></video>
  <img id="previewPhoto" style="display:none" alt="Pr√©via da foto"/>
</div>

<div id="preview-buttons">
  <button id="save" class="pbtn">Salvar</button>
  <button id="retry" class="pbtn">Refazer</button>
</div>

<div id="loading-overlay">Carregando...</div>

<script>
// --- Vari√°veis Globais ---
let stream=null;
let usingFront=true;
let recorder=null;
let recordedChunks=[];
let elapsed=0;
let timerInt=null;
let videoReady=false;
let drawInterval = null; 
let ffmpeg = null;
let ffmpegLoading = false;
let currentPreviewUrl = null; 
let ffmpegLoaded = false; // Estado do carregamento do FFmpeg

// --- Elementos DOM ---
const video=document.getElementById("video");
const frame=document.getElementById("frame");
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
const timerEl=document.getElementById("timer");
const enable=document.getElementById("enable");
const controls=document.getElementById("controls");
const loadingOverlay = document.getElementById("loading-overlay");
const switchBtn = document.getElementById('switch');
const photoBtn = document.getElementById('photo');
const recordBtn = document.getElementById('record');
const preview=document.getElementById("preview");
const previewVideo=document.getElementById("previewVideo");
const previewPhoto=document.getElementById("previewPhoto");
const previewButtons=document.getElementById("preview-buttons");
const saveBtn=document.getElementById("save");
const retryBtn=document.getElementById("retry");

// CORE PATH para a vers√£o 0.11.0, mais est√°vel no carregamento
const CORE_BASE_URL = "https://unpkg.com/@ffmpeg/core@0.11.0/dist"; 


/* -------------------------------------------------------------------------- */
/* FFmpeg e Salvamento (MP4 e Fotos)                                         */
/* -------------------------------------------------------------------------- */

async function ensureFFmpegLoaded(){
  if (ffmpegLoaded || ffmpegLoading) return true;
  ffmpegLoading = true;
  
  if (videoReady) {
      loadingOverlay.style.display = 'flex';
  } else {
      loadingOverlay.textContent = 'Carregando recursos de c√¢mera e convers√£o...';
  }

  try {
    ffmpeg = FFmpeg.createFFmpeg({ 
        log: false,
        corePath: `${CORE_BASE_URL}/ffmpeg-core.js`, 
        progress: ({ ratio }) => {
            if (ratio < 0 || ratio > 1) return;
            if (ratio > 0 && ratio < 1) { 
                loadingOverlay.textContent = `Convertendo: ${Math.round(ratio * 100)}%`;
            } else if (ratio === 0) {
                loadingOverlay.textContent = 'Preparando convers√£o...';
            }
        }
    });
    
    loadingOverlay.textContent = 'Baixando motor de convers√£o MP4 (~20MB)...';
    await ffmpeg.load();
    
    ffmpegLoaded = true;
    return true;
  } catch (e) {
    console.error('FFmpeg load failed', e);
    ffmpeg = null;
    // O alerta de falha no carregamento foi removido para evitar interrup√ß√£o.
    return false;
  } finally {
    ffmpegLoading = false;
    if (videoReady && !ffmpegLoaded) { 
         loadingOverlay.style.display = 'none';
    }
  }
}

async function handleSave(blob, fileName, fileType) {
    saveBtn.disabled = true;
    retryBtn.disabled = true;
    loadingOverlay.style.display = 'flex';
    loadingOverlay.textContent = 'Finalizando salvamento...';
    
    try {
        const file = new File([blob], fileName, { type: fileType });

        // Tenta 1: Web Share Files
        if (navigator.canShare && navigator.canShare({ files: [file] })) {
            try {
                await navigator.share({ files: [file], title: fileName.includes('video') ? 'V√≠deo Capturado' : 'Foto Capturada' });
                handleRetry(); 
                return; 
            } catch (shareError) {
                console.warn('Falha no Web Share API. Tentando Download Direto:', shareError);
            }
        }

        // Tenta 2: Download Direto
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        
        setTimeout(() => {
            a.click();
            document.body.removeChild(a);
            alert(`Download de ${fileName} iniciado! Por favor, CONFIRME O DOWNLOAD na caixa de di√°logo do seu navegador.`);
            URL.revokeObjectURL(url); 
            handleRetry();
        }, 100);
        
        document.body.appendChild(a);

    } catch (e) {
        console.error('Falha cr√≠tica no salvamento:', e);
        alert(`Falha cr√≠tica no salvamento. Erro: ${e.message}`);
        saveBtn.disabled = false;
        retryBtn.disabled = false;
    } finally {
        loadingOverlay.style.display = 'none';
    }
}

function handleRetry() {
    if (currentPreviewUrl) {
        URL.revokeObjectURL(currentPreviewUrl);
        currentPreviewUrl = null;
    }
    
    preview.style.display = 'none';
    previewButtons.style.display = 'none';
    previewPhoto.src = '';
    previewVideo.src = '';
    previewVideo.pause();
    saveBtn.onclick = null; 
    retryBtn.onclick = null; 
    saveBtn.disabled = false;
    retryBtn.disabled = false;
}


/* -------------------------------------------------------------------------- */
/* C√ÇMERA E RENDERIZA√á√ÉO 9:16 (CORRE√á√ÉO DE DRAW)                             */
/* -------------------------------------------------------------------------- */

async function startCamera(){
  try {
    if (!ffmpegLoaded && ffmpegLoading) {
        loadingOverlay.textContent = 'Recursos de convers√£o carregando em segundo plano...';
    } else {
        loadingOverlay.style.display = 'flex';
        loadingOverlay.textContent = 'Solicitando acesso √† c√¢mera...';
    }

    videoReady = false;
    if (stream) {
      stream.getTracks().forEach(t=>t.stop());
      stream = null;
    }

    const constraints = {
      video: { 
          facingMode: usingFront ? 'user' : 'environment', 
          width: { ideal: 1920 }, // Tenta resolu√ß√µes mais altas para melhor qualidade
          height: { ideal: 1080 } 
      },
      audio: true
    };

    stream = await navigator.mediaDevices.getUserMedia(constraints);

    video.srcObject = stream;
    video.muted = true;
    video.setAttribute('playsinline', '');

    await new Promise((res, rej) => {
      const onMeta = () => {
        video.removeEventListener('loadedmetadata', onMeta);
        videoReady = true;
        res();
      };
      video.addEventListener('loadedmetadata', onMeta);
      setTimeout(() => { 
        if (!videoReady) { videoReady = !!(video.videoWidth && video.videoHeight); res(); }
      }, 5000); 
    });

    await video.play();

    // UI de sucesso
    enable.style.display = 'none';
    controls.style.display = 'flex';
    if (ffmpegLoaded || !ffmpegLoading) {
        loadingOverlay.style.display = 'none';
    } else {
        loadingOverlay.textContent = 'Recursos de convers√£o MP4 carregando em segundo plano...';
    }
    
    showFrameWhenReady(); 
    drawToCanvas();
    drawLoop(); 
    
  } catch (err) {
    loadingOverlay.style.display = 'none';
    enable.style.display = 'block'; 
    
    console.error('startCamera error', err);
    let errorMessage = 'Erro desconhecido ao acessar c√¢mera.';
    if (err.name === 'NotAllowedError') {
        errorMessage = 'PERMISS√ÉO NEGADA. Voc√™ precisa permitir o acesso √† c√¢mera nas configura√ß√µes do navegador/sistema.';
    } else if (err.name === 'NotFoundError') {
        errorMessage = 'C√¢mera n√£o encontrada no dispositivo.';
    } else if (err.name === 'NotReadableError') {
        errorMessage = 'C√¢mera j√° em uso por outro aplicativo.';
    } else if (err.message) {
        errorMessage = err.message;
    }
    alert(`‚ùå FALHA CR√çTICA AO ACESSAR A C√ÇMERA: ${errorMessage}`);
  }
}

function drawToCanvas() {
    if (!videoReady) return;

    const vW = video.videoWidth;
    const vH = video.videoHeight;
    const cW = canvas.width;
    const cH = canvas.height;
    const videoRatio = vW / vH;
    const canvasRatio = cW / cH;
    let drawW, drawH, x, y;

    // 1. C√°lculo do Enquadramento
    if (videoRatio > canvasRatio) { 
        drawH = cH;
        drawW = drawH * videoRatio;
        x = (cW - drawW) / 2;
        y = 0;
    } else { 
        drawW = cW;
        drawH = drawW / videoRatio;
        x = 0;
        y = (cH - drawH) / 2;
    }

    ctx.clearRect(0, 0, cW, cH);
    
    // 2. Desenho com Espelhamento para C√¢mera Frontal (CORRE√á√ÉO)
    if (usingFront) {
        ctx.save();
        ctx.translate(cW, 0); // Move o ponto de origem para a direita
        ctx.scale(-1, 1);     // Espelha horizontalmente
        ctx.drawImage(video, x, y, drawW, drawH);
        ctx.restore();
    } else {
        // C√¢mera traseira: Desenho normal
        ctx.drawImage(video, x, y, drawW, drawH);
    }
    
    // 3. Desenho da Moldura
    if (frame.complete && frame.naturalWidth > 0 && frame.style.opacity === '1') {
        ctx.drawImage(frame, 0, 0, cW, cH);
    }
}

let drawLoopId = null;
function drawLoop(){
  if (drawLoopId) return;
  function loop(){
    if (videoReady && !drawInterval) drawToCanvas(); 
    drawLoopId = requestAnimationFrame(loop);
  }
  loop();
}

async function showFrameWhenReady() {
    try {
        await new Promise((res, rej) => {
            frame.onload = () => res();
            frame.onerror = () => res(); 
            if (frame.complete) res();
        });
        frame.style.opacity = '1';
    } catch (e) { 
        frame.style.opacity = '1'; 
    }
}

function startTimer(){
  elapsed = 0;
  timerEl.style.display = 'block';
  timerEl.textContent = '0.0s';
  timerInt = setInterval(()=> {
    elapsed += 0.1;
    timerEl.textContent = elapsed.toFixed(1) + 's';
  },100);
}

function stopTimer(){
  clearInterval(timerInt);
  timerInt = null;
  timerEl.style.display = 'none';
}


/* -------------------------------------------------------------------------- */
/* FOTO (PNG)                                                               */
/* -------------------------------------------------------------------------- */

photoBtn.addEventListener('click', async () => {
  if (!videoReady) {
    alert('Aguarde a c√¢mera carregar.');
    return;
  }

  drawToCanvas();

  const dataUrl = canvas.toDataURL('image/png');
  const blob = await (await fetch(dataUrl)).blob();
  
  preview.style.display = 'flex';
  previewPhoto.style.display = 'block';
  previewVideo.style.display = 'none';
  previewPhoto.src = dataUrl;
  previewButtons.style.display = 'flex';
  
  saveBtn.textContent = 'Salvar Foto (PNG)'; 
  saveBtn.disabled = false;
  retryBtn.disabled = false;

  saveBtn.onclick = () => {
      handleSave(blob, "foto.png", blob.type);
  };
  
  retryBtn.onclick = handleRetry;
});


/* -------------------------------------------------------------------------- */
/* V√çDEO (Grava√ß√£o e Convers√£o MP4)                                         */
/* -------------------------------------------------------------------------- */

async function startRecording(){
  if (!videoReady) {
    alert('Aguarde a c√¢mera carregar.');
    return;
  }
  
  if (drawLoopId) cancelAnimationFrame(drawLoopId); // CORRE√á√ÉO
  drawInterval = setInterval(() => {
    drawToCanvas();
  }, 33); 

  const canvasStream = canvas.captureStream(30); 
  
  const audioTracks = stream ? stream.getAudioTracks() : [];
  if (audioTracks && audioTracks.length) {
    try { canvasStream.addTrack(audioTracks[0]); } catch(e){ console.warn('Falha ao adicionar √°udio:', e); }
  }

  recordedChunks = [];
  let options = { mimeType: 'video/webm;codecs=vp8,opus' }; 

  try {
    recorder = new MediaRecorder(canvasStream, options);
  } catch (e) {
    console.error("Erro ao inicializar MediaRecorder:", e);
    alert("Erro cr√≠tico: O navegador n√£o suporta a grava√ß√£o de v√≠deo.");
    if (drawInterval) clearInterval(drawInterval);
    drawInterval = null;
    drawLoop(); // Reinicia o loop de desenho principal
    return;
  }

  recorder.ondataavailable = e => { if (e.data && e.data.size) recordedChunks.push(e.data); };

  recorder.onstop = async () => {
    stopTimer();
    if (drawInterval) clearInterval(drawInterval);
    drawInterval = null;
    drawLoop(); 
    recordBtn.classList.remove('recording');

    if (recordedChunks.length === 0) { 
        alert('Erro: Nenhuma grava√ß√£o capturada.'); 
        return; 
    }
    
    loadingOverlay.style.display = 'flex';
    loadingOverlay.textContent = 'Iniciando convers√£o...';

    const webmBlob = new Blob(recordedChunks, { type: recordedChunks[0]?.type || 'video/webm' });
    let finalBlob = webmBlob;
    let fileNameOut = 'video_capturado.webm'; 
    let fileType = 'video/webm';
    
    
    // Tenta a convers√£o para MP4
    if (ffmpegLoaded && ffmpeg) {
      try {
        
        const data = await FFmpeg.fetchFile(webmBlob);
        ffmpeg.FS('writeFile', 'input.webm', data);

        // Par√¢metros otimizados para MP4 (inclu√≠do -pix_fmt yuv420p)
        await ffmpeg.run(
          '-i','input.webm',
          '-c:v','libx264',
          '-preset','veryfast',
          '-crf','23', 
          '-c:a','aac',
          '-b:a','128k',
          '-pix_fmt','yuv420p', // CHAVE para compatibilidade
          '-movflags','faststart', 
          'output.mp4'
        );

        const mp4Data = ffmpeg.FS('readFile', 'output.mp4');
        finalBlob = new Blob([mp4Data.buffer], { type: 'video/mp4' });
        fileNameOut = 'video_capturado.mp4';
        fileType = 'video/mp4';
        
        try { ffmpeg.FS('unlink','input.webm'); ffmpeg.FS('unlink','output.mp4'); } catch(e){}
        
      } catch (e) {
        console.error('Falha na convers√£o para MP4. Usando WEBM.', e);
        // N√£o exibe alerta. Silenciosamente volta para WEBM.
      }
    }
    
    loadingOverlay.style.display = 'none';

    // Exibir pr√©via
    currentPreviewUrl = URL.createObjectURL(finalBlob);
    preview.style.display = 'flex';
    previewButtons.style.display = 'flex';
    previewPhoto.style.display = 'none';
    previewVideo.style.display = 'block';
    previewVideo.src = currentPreviewUrl;
    previewVideo.load();
    previewVideo.play();
    
    // Apenas muda o texto do bot√£o de salvar se a convers√£o falhou (WEBM)
    // N√£o usamos mais um alerta.
    if (fileType === 'video/webm') {
        console.warn('Convers√£o para MP4 falhou. O v√≠deo ser√° salvo como WEBM.');
    }

    saveBtn.textContent = `Salvar V√≠deo (${fileType.split('/')[1].toUpperCase()})`;
    saveBtn.disabled = false;
    retryBtn.disabled = false;

    saveBtn.onclick = () => {
        handleSave(finalBlob, fileNameOut, fileType);
    };

    retryBtn.onclick = handleRetry;
  };

  recorder.start();
  startTimer();
  recordBtn.classList.add('recording');
}

function stopRecording(){
  if (recorder && recorder.state !== 'inactive') {
    try { recorder.stop(); } catch(e){ console.warn(e); }
  }
}

/* -------------------------------------------------------------------------- */
/* BINDINGS E EVENTOS                                                       */
/* -------------------------------------------------------------------------- */

switchBtn.addEventListener('click', async () => {
    usingFront = !usingFront;
    await startCamera();
});

document.addEventListener('DOMContentLoaded', ensureFFmpegLoaded);

(function bindPressHold(){
  recordBtn.addEventListener('contextmenu', e => e.preventDefault());

  const handleStartRecording = async (e) => {
    e.preventDefault();
    if (!videoReady) await startCamera();
    if (recorder && recorder.state !== 'inactive') return; 
    await startRecording();
  };
  
  const handleStopRecording = (e) => {
    e.preventDefault();
    stopRecording();
  };

  recordBtn.addEventListener('pointerdown', handleStartRecording);
  recordBtn.addEventListener('pointerup', handleStopRecording);
  recordBtn.addEventListener('pointercancel', handleStopRecording);

  recordBtn.addEventListener('touchstart', handleStartRecording, {passive:false});
  recordBtn.addEventListener('touchend', handleStopRecording, {passive:false});
  recordBtn.addEventListener('touchcancel', handleStopRecording, {passive:false});

  recordBtn.addEventListener('click', async (e) => {
    e.preventDefault();
    if (!recorder || recorder.state === 'inactive') {
      if (!videoReady) await startCamera();
      await startRecording();
      setTimeout(()=> {
          if (recorder && recorder.state === 'recording') {
              stopRecording();
          }
      }, 3000); 
    } else {
      stopRecording();
    }
  });
})();

window.addEventListener('pagehide', () => {
  try {
    if (stream) stream.getTracks().forEach(t=>t.stop());
    if (currentPreviewUrl) URL.revokeObjectURL(currentPreviewUrl);
  } catch(e){}
});
</script>
</body>
</html>
