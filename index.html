<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<title>Moldura Criativa - C√¢mera Final</title>

<script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.5/dist/ffmpeg.min.js"></script>

<style>
  * { margin:0; padding:0; box-sizing:border-box; }
  html, body {
    width:100%; height:100%;
    background:#000;
    overflow:hidden;
    font-family:system-ui, -apple-system;
    -webkit-user-select:none;
    user-select:none;
    -webkit-touch-callout:none;
    touch-action:manipulation;
  }

  /* V√≠deo da c√¢mera */
  #video {
    position:fixed; inset:0;
    width:100vw; height:100vh;
    object-fit:cover;
    z-index:1;
    pointer-events:none;
    background:#000;
  }

  /* Moldura */
  #frame {
    position:fixed; inset:0;
    width:100vw; height:100vh;
    object-fit:contain;
    z-index:3;
    pointer-events:none;
    opacity:0;              /* carregamento r√°pido */
    transition:opacity .2s;
  }

  /* Bot√£o ativar c√¢mera */
  #enable {
    position:fixed; left:50%; top:50%;
    transform:translate(-50%, -50%);
    background:#fff; color:#000;
    padding:18px 28px;
    border:none; border-radius:12px;
    font-size:20px;
    z-index:20;
  }

  /* Controles */
  #controls {
    position:fixed; bottom:30px; left:0; right:0;
    display:none; justify-content:center; gap:40px;
    z-index:10;
  }

  .btn {
    width:80px; height:80px;
    background:#fff; border-radius:50%;
    border:none;
    font-size:30px;
    display:flex; align-items:center; justify-content:center;
    box-shadow:0 0 20px #0008;
    touch-action:none;
  }
  
  /* Indicador de grava√ß√£o */
  .btn.recording {
    background: red;
    box-shadow: 0 0 0 8px rgba(255, 0, 0, 0.5);
  }

  /* Timer */
  #timer {
    position:fixed; top:20px; left:50%;
    transform:translateX(-50%);
    font-size:28px; color:#fff;
    display:none; font-weight:600;
    z-index:20;
  }

  /* Pr√©via */
  #preview {
    position:fixed; inset:0;
    background:#000;
    z-index:30;
    display:none;
    justify-content:center;
    align-items:center;
  }

  #preview video,
  #preview img {
    max-width:100%;
    max-height:100%;
    object-fit:contain;
    pointer-events:auto;
  }

  /* Bot√µes Salvar / Refazer (VERTICAL) */
  #preview-buttons {
    position:fixed; bottom:30px; left:0; right:0;
    display:none;
    flex-direction:column;
    align-items:center;
    gap:20px;
    z-index:40;
    pointer-events:auto;
  }

  .pbtn {
    padding:16px 28px;
    background:#fff;
    border:none;
    border-radius:12px;
    font-size:20px;
    color:#000;
    width:60%;
    text-align:center;
  }
  
  .pbtn:disabled {
      opacity: 0.7;
      cursor: not-allowed;
  }
</style>
</head>
<body>

<button id="enable">Ativar C√¢mera</button>

<video id="video" autoplay playsinline muted></video>
<img id="frame" src="assets/moldura.png" alt="Moldura"/>

<canvas id="canvas" width="1080" height="1920" style="display:none"></canvas>

<div id="controls">
  <button id="switch" class="btn">üîÑ</button>
  <button id="photo" class="btn">üì∏</button>
  <button id="record" class="btn">‚è∫</button>
</div>

<div id="timer">0.0s</div>

<div id="preview">
  <video id="previewVideo" controls playsinline style="display:none"></video>
  <img id="previewPhoto" style="display:none" alt="Pr√©via da foto"/>
</div>

<div id="preview-buttons">
  <button id="save" class="pbtn">Salvar</button>
  <button id="retry" class="pbtn">Refazer</button>
</div>

<script>
let stream=null;
let usingFront=true;
let recorder=null;
let chunks=[];
let elapsed=0;
let timerInt=null;
let videoReady=false;

const video=document.getElementById("video");
const frame=document.getElementById("frame");
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");

const preview=document.getElementById("preview");
const previewVideo=document.getElementById("previewVideo");
const previewPhoto=document.getElementById("previewPhoto");
const previewButtons=document.getElementById("preview-buttons");
const timerEl=document.getElementById("timer");

const enable=document.getElementById("enable");
const controls=document.getElementById("controls");

const saveBtn=document.getElementById("save");
const retryBtn=document.getElementById("retry");
/* --------------------- PARTE 2 (CONTINUA√á√ÉO) --------------------- */

const switchBtn = document.getElementById('switch');
const photoBtn = document.getElementById('photo');
const recordBtn = document.getElementById('record');

let ffmpeg = null;
let ffmpegLoading = false;

/* -------------------------------------------------------------------------- */
/* FUN√á√ïES BASE                               */
/* -------------------------------------------------------------------------- */

/* ---------- util: show/hide frame quickly after load ---------- */
async function showFrameWhenReady() {
  try {
    // wait overlay image loaded but don't block camera show
    if (frame && !frame.complete) {
      await new Promise((res, rej) => {
        frame.onload = () => res();
        frame.onerror = () => res(); // ignore error, still continue
      });
    }
    frame.style.opacity = '1';
  } catch (e) { frame.style.opacity = '1'; }
}

/* ---------- start camera, wait metadata for reliable readiness ---------- */
async function startCamera(){
  try {
    videoReady = false;
    // stop previous
    if (stream) {
      stream.getTracks().forEach(t=>t.stop());
      stream = null;
    }

    // lightweight constraints for fast open; we scale in canvas later
    const constraints = {
      video: { facingMode: usingFront ? 'user' : 'environment', width: { ideal: 1280 }, height: { ideal: 720 } },
      audio: true
    };

    stream = await navigator.mediaDevices.getUserMedia(constraints);

    video.srcObject = stream;
    video.muted = true;
    video.setAttribute('playsinline', '');

    // Wait for metadata (videoWidth/videoHeight available)
    await new Promise((res, rej) => {
      if (video.readyState >= 1 && video.videoWidth && video.videoHeight) {
        videoReady = true;
        return res();
      }
      const onMeta = () => {
        video.removeEventListener('loadedmetadata', onMeta);
        videoReady = true;
        res();
      };
      video.addEventListener('loadedmetadata', onMeta);
      // safety timeout (5s)
      setTimeout(() => {
        if (!videoReady) { videoReady = !!(video.videoWidth && video.videoHeight); res(); }
      }, 5000);
    });

    await video.play();

    // show UI
    enable.style.display = 'none';
    controls.style.display = 'flex';

    // reveal frame (load frame image in background)
    showFrameWhenReady();

    // pre-draw once so canvas has something if user presses immediately
    drawToCanvas();
  } catch (err) {
    console.error('startCamera error', err);
    alert('Erro ao acessar c√¢mera: ' + (err && err.message ? err.message : err));
  }
}

/* ---------- drawToCanvas: ESSENCIAL para renderizar v√≠deo + moldura ---------- */
function drawToCanvas() {
    if (!videoReady) return;

    const vW = video.videoWidth;
    const vH = video.videoHeight;
    const cW = canvas.width;
    const cH = canvas.height;

    // Calcule a propor√ß√£o de cobertura (cover)
    const videoRatio = vW / vH;
    const canvasRatio = cW / cH;

    let drawW, drawH, x, y;

    // L√≥gica para que o v√≠deo preencha toda a √°rea (object-fit: cover)
    if (videoRatio > canvasRatio) { // V√≠deo mais largo que o canvas
        drawH = cH;
        drawW = drawH * videoRatio;
        x = (cW - drawW) / 2;
        y = 0;
    } else { // V√≠deo mais alto que o canvas
        drawW = cW;
        drawH = drawW / videoRatio;
        x = 0;
        y = (cH - drawH) / 2;
    }

    // 1. Limpa o canvas
    ctx.clearRect(0, 0, cW, cH);
    
    // 2. Desenha o v√≠deo (redimensionado para cobrir)
    ctx.drawImage(video, x, y, drawW, drawH);

    // 3. Desenha a moldura por cima (redimensionada para conter)
    if (frame.complete && frame.naturalWidth > 0 && frame.style.opacity === '1') {
        ctx.drawImage(frame, 0, 0, cW, cH);
    }
}

/* ---------- draw loop used for preview and to ensure canvas updated ---------- */
let drawLoopId = null;
function drawLoop(){
  if (drawLoopId) return;
  function loop(){
    if (videoReady) drawToCanvas();
    drawLoopId = requestAnimationFrame(loop);
  }
  loop();
}
function stopDrawLoop(){
  if (drawLoopId) {
    cancelAnimationFrame(drawLoopId);
    drawLoopId = null;
  }
}

/* -------------------------------------------------------------------------- */
/* FOTO (IMAGEM)                             */
/* -------------------------------------------------------------------------- */

photoBtn.addEventListener('click', async () => {
  if (!videoReady) {
    alert('Aguarde a c√¢mera carregar.');
    return;
  }

  // draw final frame
  drawToCanvas();

  // convert to blob
  const dataUrl = canvas.toDataURL('image/png');
  const blob = await (await fetch(dataUrl)).blob();
  const file = new File([blob], "foto.png", { type: blob.type });

  // show preview fullscreen
  preview.style.display = 'flex';
  previewPhoto.style.display = 'block';
  previewVideo.style.display = 'none';
  previewPhoto.src = dataUrl;
  previewButtons.style.display = 'flex';
  
  saveBtn.textContent = 'Salvar'; // Garante o texto correto
  saveBtn.disabled = false;
  retryBtn.disabled = false;

  // ** L√≥gica Salvar Foto **
  saveBtn.onclick = async () => {
    try {
      // 1. Tenta Web Share Files
      if (navigator.canShare && navigator.canShare({ files: [file] })) {
        await navigator.share({ files: [file], title: "Foto Capturada" });
      } 
      // 2. Tenta Web Share URL (Fallback menos comum)
      else if (navigator.share) {
        const url = URL.createObjectURL(blob);
        try {
          await navigator.share({ url, title: "Foto Capturada" });
        } finally {
          URL.revokeObjectURL(url);
        }
      } 
      // 3. Fallback para Download Direto (Mais confi√°vel)
      else {
        const a = document.createElement('a');
        a.href = dataUrl;
        a.download = 'foto.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      }
    } catch (e) {
      console.warn('Share/save failed, fallback to download', e);
      const a = document.createElement('a');
      a.href = dataUrl;
      a.download = 'foto.png';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }
  };
  
  // ** L√≥gica Refazer Foto **
  retryBtn.onclick = () => {
    preview.style.display = 'none';
    previewButtons.style.display = 'none';
    previewPhoto.src = '';
  };
});

/* -------------------------------------------------------------------------- */
/* V√çDEO (GRAVA√á√ÉO)                             */
/* -------------------------------------------------------------------------- */

async function ensureFFmpegLoaded(){
  if (ffmpeg || ffmpegLoading) return;
  ffmpegLoading = true;
  console.log('Iniciando carregamento do FFmpeg...');
  try {
    // Definindo o corePath explicitamente para garantir que seja encontrado no CDN
    const CORE_PATH = 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.5/dist/ffmpeg-core.js';
    ffmpeg = FFmpeg.createFFmpeg({ log: false, corePath: CORE_PATH });
    await ffmpeg.load();
    console.log('FFmpeg carregado com sucesso.');
  } catch (e) {
    console.error('FFmpeg load failed', e);
    ffmpeg = null;
    alert('Erro ao carregar o FFmpeg. A convers√£o de v√≠deo para MP4 falhar√°, mas o v√≠deo WEBM pode ser salvo.');
  } finally {
    ffmpegLoading = false;
  }
}

async function startRecording(){
  if (!videoReady) {
    // small wait
    const started = await new Promise(res => {
      let waited = 0;
      const check = setInterval(() => {
        waited += 100;
        if (video.videoWidth && video.videoHeight) {
          clearInterval(check); res(true);
        } else if (waited > 3000) { clearInterval(check); res(false); }
      }, 100);
    });
    if (!started) return;
  }

  // ensure at least one draw
  drawToCanvas();

  // capture canvas stream with audio
  const canvasStream = canvas.captureStream(30);
  const audioTracks = stream ? stream.getAudioTracks() : [];
  if (audioTracks && audioTracks.length) {
    try { canvasStream.addTrack(audioTracks[0]); } catch(e){ console.warn('addTrack failed', e); }
  }

  let recordedChunks = [];
  let options = {};
  // Tentativa de usar VP8/Opus (mais comum em navegadores)
  const mime = 'video/webm;codecs=vp8,opus'; 
  try { if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(mime)) options.mimeType = mime; } catch(e){}

  recorder = new MediaRecorder(canvasStream, options);
  recorder.ondataavailable = e => { if (e.data && e.data.size) recordedChunks.push(e.data); };

  recorder.onstop = async () => {
    stopTimer();
    recordBtn.classList.remove('recording');
    console.log('Grava√ß√£o finalizada. Total de chunks:', recordedChunks.length);


    if (recordedChunks.length === 0) {
        alert('Erro: Nenhuma grava√ß√£o capturada. Tente novamente.');
        // Oculta pr√©via e bot√µes se a grava√ß√£o falhou
        preview.style.display = 'none';
        previewButtons.style.display = 'none';
        return;
    }

    const webmBlob = new Blob(recordedChunks, { type: recordedChunks[0]?.type || 'video/webm' });
    const webmUrl = URL.createObjectURL(webmBlob);

    // show preview (loading state)
    preview.style.display = 'flex';
    previewButtons.style.display = 'flex';
    previewPhoto.style.display = 'none';
    previewVideo.style.display = 'block';
    previewVideo.src = ''; // clear previous

    let finalBlob = webmBlob;
    let finalFileName = 'video.webm';
    let finalFileType = 'video/webm';
    let finalUrl = webmUrl;

    // convert to MP4 using ffmpeg (lazy load)
    try {
      await ensureFFmpegLoaded();
      if (!ffmpeg) throw new Error('ffmpeg failed to load or was not available.');

      // Feedback de convers√£o
      previewVideo.style.filter = 'brightness(50%)';
      saveBtn.disabled = true;
      retryBtn.disabled = true;
      saveBtn.textContent = 'Processando V√≠deo...';
      console.log('Iniciando convers√£o para MP4...');

      const data = await FFmpeg.fetchFile(webmBlob);
      ffmpeg.FS('writeFile', 'input.webm', data);

      await ffmpeg.run(
        '-i','input.webm',
        '-c:v','libx264',
        '-preset','veryfast',
        '-crf','23',
        '-c:a','aac',
        '-b:a','128k',
        '-movflags','faststart',
        'output.mp4'
      );

      const mp4Data = ffmpeg.FS('readFile', 'output.mp4');
      const mp4Blob = new Blob([mp4Data.buffer], { type: 'video/mp4' });
      const mp4Url = URL.createObjectURL(mp4Blob);

      // Atualiza vari√°veis finais para MP4
      finalBlob = mp4Blob;
      finalFileName = 'video.mp4';
      finalFileType = 'video/mp4';
      finalUrl = mp4Url;
      console.log('Convers√£o para MP4 bem-sucedida.');

      // cleanup ffmpeg FS
      try { ffmpeg.FS('unlink','input.webm'); ffmpeg.FS('unlink','output.mp4'); } catch(e){}
    } catch (e) {
      console.error('Erro na convers√£o para MP4. Usando WEBM como fallback.', e);
      // Fallback para WEBM √© autom√°tico, vari√°veis finais j√° est√£o com webmBlob/webmUrl
    } finally {
      // Restaura o estado da UI
      previewVideo.style.filter = 'none';
      saveBtn.disabled = false;
      retryBtn.disabled = false;
      saveBtn.textContent = 'Salvar';

      // Exibe o v√≠deo final (MP4 ou WEBM fallback)
      previewVideo.src = finalUrl;
      previewVideo.load();
      console.log('Pr√©via do v√≠deo configurada. Configurando bot√µes Salvar/Refazer.');


      // ** L√≥gica Salvar V√≠deo (Corrigida) **
      saveBtn.onclick = async () => {
        try {
          const file = new File([finalBlob], finalFileName, { type: finalFileType });
          
          // 1. Tenta Web Share Files
          if (navigator.canShare && navigator.canShare({ files: [file] })) {
            await navigator.share({ files: [file], title: 'V√≠deo Capturado' });
          } 
          // 2. Tenta Web Share URL (Fallback menos comum)
          else if (navigator.share) {
             const tempUrl = URL.createObjectURL(finalBlob);
             try {
                await navigator.share({ url: tempUrl, title: 'V√≠deo Capturado' });
             } finally {
                URL.revokeObjectURL(tempUrl);
             }
          } 
          // 3. Fallback para Download Direto (Mais confi√°vel)
          else {
            const a = document.createElement('a');
            a.href = finalUrl;
            a.download = finalFileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
          }
        } catch (e) {
          console.warn('Share failed, fallback to download', e);
          const a = document.createElement('a');
          a.href = finalUrl;
          a.download = finalFileName;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
        }
      };

      // ** L√≥gica Refazer V√≠deo (Corrigida) **
      retryBtn.onclick = () => {
        preview.style.display = 'none';
        previewButtons.style.display = 'none';
        previewVideo.pause();
        previewVideo.src = '';
        URL.revokeObjectURL(webmUrl); // Limpa o webm original
        if (finalUrl && finalUrl !== webmUrl) {
            URL.revokeObjectURL(finalUrl); // Limpa o mp4 se for diferente
        }
        console.log('Refazer v√≠deo executado. URLs revogadas.');
      };
    }
  };

  recorder.start();
  startTimer();
  recordBtn.classList.add('recording');

  // animation: continuously draw to canvas while recording
  (function anim(){
    if (recorder && recorder.state !== 'inactive') {
      drawToCanvas();
      requestAnimationFrame(anim);
    }
  })();
}

function stopRecording(){
  if (recorder && recorder.state !== 'inactive') {
    try { recorder.stop(); } catch(e){ console.warn(e); }
  }
}

/* -------------------------------------------------------------------------- */
/* CONTROLES                                */
/* -------------------------------------------------------------------------- */

/* ---------- Timer helpers ---------- */
function startTimer(){
  elapsed = 0;
  timerEl.style.display = 'block';
  timerEl.textContent = '0.0s';
  timerInt = setInterval(()=> {
    elapsed += 0.1;
    timerEl.textContent = elapsed.toFixed(1) + 's';
  },100);
}

function stopTimer(){
  clearInterval(timerInt);
  timerInt = null;
  timerEl.style.display = 'none';
}

/* ---------- Press & hold binding (pointer + touch fallbacks) ---------- */
(function bindPressHold(){
  // Prevent default context
  recordBtn.addEventListener('contextmenu', e => e.preventDefault());

  // Iniciar Grava√ß√£o
  recordBtn.addEventListener('pointerdown', async (e) => {
    e.preventDefault();
    if (!videoReady) {
      await startCamera();
    }
    await startRecording();
  });

  // Parar Grava√ß√£o
  const stopEvents = (e) => {
    e.preventDefault();
    stopRecording();
  };
  recordBtn.addEventListener('pointerup', stopEvents);
  recordBtn.addEventListener('pointercancel', stopEvents);

  // touch fallback
  recordBtn.addEventListener('touchstart', async (e) => { e.preventDefault(); if (!videoReady) await startCamera(); await startRecording(); }, {passive:false});
  recordBtn.addEventListener('touchend', stopEvents, {passive:false});
  recordBtn.addEventListener('touchcancel', stopEvents, {passive:false});

  // click fallback: quick tap toggles short recording (accessibility)
  recordBtn.addEventListener('click', async (e) => {
    e.preventDefault();
    if (!recorder) {
      if (!videoReady) await startCamera();
      await startRecording();
      // auto-stop after 3s for click fallback
      setTimeout(()=> stopRecording(), 3000);
    } else {
      stopRecording();
    }
  });
})();

/* ---------- Outros Bot√µes de Controle ---------- */

// Bot√£o Ativar C√¢mera
enable.addEventListener('click', startCamera);

// Bot√£o Trocar C√¢mera
switchBtn.addEventListener('click', async () => {
    usingFront = !usingFront;
    await startCamera();
});

/* ---------- Ensure preview buttons are clickable (fix pointer-events issues) ---------- */
previewButtons.addEventListener('click', (e) => {
  // clicks are handled by saveBtn/retryBtn assigned dynamically; stop propagation
  e.stopPropagation();
});

/* ---------- Inicializa√ß√£o ---------- */

// Auto-start draw loop (keeps canvas updated in background)
drawLoop();

// final touch: when page hidden, stop camera
window.addEventListener('pagehide', () => {
  try {
    if (stream) stream.getTracks().forEach(t=>t.stop());
  } catch(e){}
  stopDrawLoop();
});

/* --------------------- FIM DO ARQUIVO COMPLETO --------------------- */
</script>
</body>
</html>
